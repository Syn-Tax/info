---
layout: default
title: Topic 4 CTPSP Syllabus
parent: Programming
grand_parent: IB DP Core
nav_order: 1
---
Core
{: .label .label-blue }

# Topic 4 - Computational thinking, problem-solving and programming

(45 hours: 60 periods/15 weeks)

#### **(AO: 1) = Assessment objective 1:**  
classify, define, draw, label, list, state

#### **(AO: 2) = Assessment objective 2:**  
annotate, apply, calculate, describe, design, distinguish, estimate, identify, outline, present, trace

#### **(AO: 3) = Assessment objective 3:**  
analyse, comment, compare, compare and contrast, construct, contrast, deduce, demonstrate, derive, determine, discuss, evaluate, examine, explain, formulate, interpret, investigate, justify, predict, sketch, suggest, to what extent
---

## 4.1 General principles
### (10 hours)

This should not be taught as a separate topic but must be incorporated and connected to all sections - especially flow charts, pseudocode and programming in the SL/HL core and abstract data structures (HL extension). It is essential that these elements are not addressed in isolation - they have to be approached as a whole.

The basic ideas and their application should be illustrated with non-computer examples. Each basic idea should then be practised in specific algorithmic contexts using concepts drawn from flow charts, pseudocode and programming. The teacher support material illustrates examples such as the home/locker/ knapsack for thinking ahead.

### Thinking procedurally 	

4.1.1  
Identify the procedure appropriate to solving a problem. (AO: 2)  
This includes identifying the steps and putting them in the correct order. Such as recipes, block-arrow-block- arrow.  
LINK: Connecting computational thinking and program design, introduction to programming. 	 	

4.1.2  
Evaluate whether the order in which activities are undertaken will result in the required outcome. (AO: 3)  
Links to problems presented to the student in other areas of the syllabus.  
LINK: Thinking ahead, thinking concurrently. Connecting computational thinking and program design, introduction to programming.	 	

4.1.3  
Explain the role of sub-procedures in solving a problem. (AO: 3)  
Constructing procedures that can then be referred to by their identifier.  
LINK: Abstraction, connecting computational thinking and program design, introduction to programming.

### Thinking logically

4.1.4  
Identify when decision-making is required in a specified situation. (AO: 2)  	Links to procedural thinking— alternative procedures.  
TOK Reasoning as a form of decision-making.  
LINK Connecting computational thinking and program design, introduction to programming.  
0clip_image042.png

4.1.5  
Identify the decisions required for the solution to a specified problem. (AO: 2)  
Different actions are taken based on conditions.  
LINK Connecting computational thinking and program design, introduction to programming.  
AIM 4 Applying thinking skills to identify and resolve a specified complex problem.  

4.1.6  
Identify the condition associated with a given decision in a specified problem. (AO: 2)  
Testing conditions, iteration. Identifying and constructing the conditions—AND, OR, NOT relationships—Boolean tests.  
LINK: Connecting computational thinking and program design, introduction to programming.

4.1.7  
Explain the relationship between the decisions and conditions of a system. (AO: 3)  
IF ... THEN ... ELSE  
LINK: Connecting computational thinking and program design, introduction to programming.

4.1.8  
Deduce logical rules for real-world situations. (AO: 3)  
LINK: Connecting computational thinking and program design, introduction to programming.

### Thinking ahead
4.1.9  
Identify the inputs and outputs required in a solution. (AO: 2)  	 	 	

4.1.10  
Identify pre-planning in a suggested problem and solution. (AO: 2)  
Gantt charts.  
Pre-ordering.  
Pre-heating an oven.  
Home/locker/knapsack.  
Caching/pre-fetching.  
Building libraries of pre-formed elements for future use.  
LINK: Thinking procedurally,  thinking concurrently. Connecting computational thinking and program design, introduction to programming.

4.1.11  
Explain the need for pre-conditions when executing an algorithm. (AO: 3)	 	 	

4.1.12  
Outline the pre- and post-conditions to a specified problem. (AO: 2)  
For example, cooking a dish for a meal. All ingredients available before starting to cook. A place to eat the food.

4.1.13  
Identify exceptions that need to be considered in a specified problem solution. (AO: 2)  
For example, identify the pre- conditions for calculating the end-of-year bonus when not all employees have worked for the company for the whole year.  
LINK: Connecting computational thinking and program design, introduction to programming.

### Thinking concurrently 	 	
4.1.14  
Identify the parts of a solution that could be implemented concurrently. (AO: 2)  
Could include computer systems or real-life situations.  
LINK: Thinking ahead, thinking procedurally. Connecting computational thinking and program design, introduction to programming.

4.1.15  
Describe how concurrent processing can be used to solve a problem. (AO: 2)  
For example, building a house, production lines, division of labour.  
Students will not be expected to construct a flow chart or pseudocode related to concurrent processing.

4.1.16  
Evaluate the decision to use concurrent processing in solving a problem. (AO: 3)  
LINK Thinking ahead, thinking procedurally. Connecting computational thinking and program design, introduction to programming.

### Thinking abstractly 	 	
4.1.17  
Identify examples of abstraction. (AO: 2)  
Selecting the pieces of information that are relevant to solving the problem.  
LINK: Thinking ahead.

4.1.18  
Explain why abstraction is required in the derivation of computational solutions for a specified situation. (AO: 3)  
Students should be aware of the concept of objects, for example, the use of collections as objects in the design of algorithms.  
LINK:  
*   Databases: tables, queries 	 	
*   Modelling and simulation: an abstraction of reality 	 	
*   OOP: classes, sub-classes 	 	
*   Web science: distributed applications 

4.1.19  
Construct an abstraction from a specified situation. (AO: 3)  
There is no need to use code.  
Levels of abstraction through successive decomposition.  
A school can be decomposed into faculties. A faculty can be decomposed into departments.  
LINK: Thinking ahead, thinking procedurally. Connecting computational thinking and program design, introduction to programming.

4.1.20  
Distinguish between a real-world entity and its abstraction. (AO: 2)  
TOK: The map as an abstraction of the territory.

## 4.2 Connecting computational thinking and program design
### (22 hours)  

The focus of this topic is how an understanding of programming languages enhances the students’ understanding of computational thinking and provides them with opportunities for practical, hands-on experience of applying computational thinking to practical outcomes.  
In externally assessed components questions will be presented using flow charts and/or pseudocode as outlined in the approved notation sheet. Answers will only be required in pseudocode.  
Students must be given the opportunity to convert algorithms into working code that is executed and tested.  
Working code will not be assessed in the externally assessed components.  

4.2.1  
Describe the characteristics of standard algorithms on linear arrays. (AO: 2)  
These are: sequential search, binary search, bubble sort, selection sort.  

4.2.2  
Outline the standard operations of collections. (AO: 2)  
These are: addition and retrieval of data.  

4.2.3  
Discuss an algorithm to solve a specific problem. (AO: 3)  
Students should be expected to discuss the differences between algorithms, including both standard and novel algorithms. For example, discussing the advantages and disadvantages of using a binary search as opposed to a sequential search.  

4.2.4  
Analyse an algorithm presented as a flow chart. (AO: 3)  
Examination questions may involve variables, calculations, simple and nested loops, simple conditionals and multiple or nested conditionals.  
This would include tracing an algorithm as well as assessing its correctness.  
Students will not be expected to construct a flow chart to represent an algorithm in an externally assessed component.  

4.2.5  
Analyse an algorithm presented as pseudocode. (AO: 3)  
Examination questions may involve variables, calculations, simple and nested loops, simple conditionals and multiple or nested conditionals.  
This would include tracing an algorithm as well as assessing its correctness.  

4.2.6  
Construct pseudocode to represent an algorithm. (AO: 3)  
AIM 4: Demonstrate thinking skills to represent a possible solution to a specified complex problem.  

4.2.7  
Suggest suitable algorithms to solve a specific problem. (AO: 3)  
Suitable algorithms may include both standard algorithms and novel algorithms. Suitable may include considerations of efficiency, correctness, reliability and flexibility. Students are expected to suggest algorithms that will actually solve the problem successfully.  
LINK: General principles of computational thinking, introduction to programming.  

4.2.8  
Deduce the efficiency of an algorithm in the context of its use. (AO: 3)  
Students should understand and explain the difference in efficiency between a single loop, nested loops, a loop that ends when a condition is met or questions of similar complexity.  
Students should also be able to suggest changes in an algorithm that would improve efficiency, for example, using a flag to stop a search immediately when an item is found, rather than continuing the search through the entire list.  

4.2.9  
Determine the number of times a step in an algorithm will be performed for given input data. (AO: 3)  
Examination questions will involve specific algorithms (in pseudocode/ flow charts), and students may be expected to give an actual number (or range of numbers) of iterations that a step will execute.  

## 4.3 Introduction to programming
### (13 hours)  

### Nature of programming languages  

4.3.1  
State the fundamental operations of a computer. (AO: 1)  
These include: add, compare, retrieve and store data.  
Complex capabilities are composed of very large numbers of very simple operations.  

4.3.2  
Distinguish between fundamental and compound operations of a computer. (AO: 2)  
For example, “find the largest” is a compound operation.  

4.3.3  
Explain the essential features of a computer language. (AO: 3)  
For example, fixed vocabulary, unambiguous meaning, consistent grammar and syntax.  
TOK Language and meaning.  

4.3.4  
Explain the need for higher level languages. (AO: 3)  
For example, as the human needs for computer systems have expanded it is necessary to abstract from the basic operations of the computer. It would take far too long to write the type of systems needed today in machine code.  

4.3.5  
Outline the need for a translation process from a higher level language to machine executable code. (AO: 2)  
For example, compiler, interpreter, virtual machine.  

### Use of programming languages  

Sub-programmes and objects support abstraction, which facilitates: ease of debugging and maintenance, reuse of code, modularity.  

There is no programming language specified in the SL/HL core. However, students must use a language that supports the basic constructs on the approved notation sheet.  

4.3.6  
Define the terms: variable, constant, operator, object. (AO: 1)  

4.3.7  
Define the operators =, ≠, <, <=, >, >=, mod, div. (AO: 1)  
LINK: Approved notation sheet.  

4.3.8  
Analyse the use of variables, constants and operators in algorithms. (AO: 3)  
For example, identify and justify the use of a constant as opposed to a variable in a given situation.  

4.3.9  
Construct algorithms using loops, branching. (AO: 3)  
Teachers must ensure algorithms use the symbols from the approved notation sheet.  
LINK: Approved notation sheet.  
LINK: Connecting computational thinking and program design.  

4.3.10  
Describe the characteristics and applications of a collection. (AO: 2)  
Characteristics: • Contains similar elements.  

LINK: HL extension, recursive thinking.  
LINK: General principles of computational thinking, connecting computational thinking and program design.  

4.3.1.1  
Construct algorithms using the access methods of a collection. (AO: 3)  
LINK: Connecting computational thinking and program design.  

4.3.1.2  
Discuss the need for sub-programmes and collections within programmed solutions. (AO: 3)  
Show an understanding of the usefulness of reusable code and program organization for the individual programmer, team members and future maintenance.  
LINK: General principles of computational thinking, connecting computational thinking and program design.  

4.3.1.3  
Construct algorithms using pre- defined sub-programmes, one- dimensional arrays and/or collections. (AO: 3)  
Students will only be required to analyse flow charts in the externally assessed components.  
Students will be expected to write and analyse pseudocode in the externally assessed components.  
S/E, AIM 8: Appreciate the implications of using available code from sources such as online forums.  
LINK: Connecting computational thinking and program design.  
